<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jonliu Blog</title>
    <description>记录生活、学习的点滴...</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 19 Apr 2018 16:59:02 +0800</pubDate>
    <lastBuildDate>Thu, 19 Apr 2018 16:59:02 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>由tornado引发的一些思考</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s cool. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近接触到公司的长轮训项目，用于实现好友列表页消息实时更新，看到组里的小伙伴是用tornado写的项目，所以进行一些研究。&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;关于epoll&quot;&gt;关于epoll&lt;/h2&gt;
&lt;p&gt;epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;它能显著提高程序在&lt;code class=&quot;highlighter-rouge&quot;&gt;大量并发连接中只有少量活跃&lt;/code&gt;的情况下的&lt;code class=&quot;highlighter-rouge&quot;&gt;系统CPU利用率&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;原因就是获取事件的时候，它无须遍历&lt;code class=&quot;highlighter-rouge&quot;&gt;整个被侦听的文件描述符集&lt;/code&gt;，只要遍历那些被&lt;code class=&quot;highlighter-rouge&quot;&gt;内核IO事件&lt;/code&gt;异步唤醒而加入&lt;code class=&quot;highlighter-rouge&quot;&gt;Ready队列&lt;/code&gt;的描述符集合就行了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;tornado是通过epoll方式实现的异步IO框架，所以它虽然是单进程单线程，但是可以通过异步IO的方式保持成千上万的连接。&lt;/p&gt;

&lt;h2 id=&quot;web-server与web-app&quot;&gt;web server与web app&lt;/h2&gt;
&lt;p&gt;WSGI的全称是Web Server Gateway Interface，这是一个规范，约定了web服务器&lt;code class=&quot;highlighter-rouge&quot;&gt;怎么调用&lt;/code&gt;web应用程序的代码、web应用&lt;code class=&quot;highlighter-rouge&quot;&gt;如何处理&lt;/code&gt;请求(比如常用的wsgi:gunicorn的-k网络模型，-w进程数，-b绑定的host:port，-c配置web app的文件等等)。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;只要web应用程序和web服务器都遵守WSGI 协议，那么，web应用程序和web服务器就可以随意的组合&lt;/code&gt;。正是因为WSGI规范，所以无论是什么语言实现的什么web框架都可以与nginx拼接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/python-tornado-1.jpeg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中web server通常是nginx/apache,WSGI可以是gunicorn/uwsgi/tornado, web框架可以是django
由于tornado实现了web server和wsgi协议，所以可以通过如下方式提高服务器的效率：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 * nginx -&amp;gt; n * wsgi(tornado实现) 

1 * wsgi-&amp;gt; n * django(web app)进程

说明：nginx是多进程的所以能起多个web app进行负载均衡,WSGI接口对应多个web app worker,gunicorn也支持epoll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;另外：tornado在实现websocket和长轮训方面有着天然的优势(例如：社交产品中，server与client端保持长轮训，实时更新用户消息.游戏服务器中websocket保持实时状态)&lt;/p&gt;

&lt;h2 id=&quot;关于websocket和长轮训&quot;&gt;关于websocket和长轮训&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;长轮训通常是发出http请求，等待回应，此时并不断开连接，所以io阻塞，而tornado实现了异步io，在长轮训保持不活跃的连接时，tornado可以异步地去建立其他的连接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;websocket客户端发出一个较大http请求，其中包含…,与服务器建立连接，一旦建立连接，中间的数据传输使用tcp协议通信数据，不过每个数据包会多几个bytes的websocket协议头。同理，websocket也是建立了一个长连接，所以异步io的tornado非常适合！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 19 Apr 2018 05:57:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/19/python-tornado/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/19/python-tornado/</guid>
        
        <category>Python</category>
        
        
      </item>
    
  </channel>
</rss>
